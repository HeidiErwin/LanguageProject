Things Heidi needs to do UI/UX/Unity-wise:
[DONE] refactor WordPiece into ExpressionPiece
[DONE] make a GameController class to set up the keyboard / add expressions to the screen
	   will definitely be useful if not necessary later anyways
[DONE] expressionPiece.CanAccept --> GET and KEY working fine, bug w/ F & X
[DONE] expressionPiece.DetermineUpdatedSprite
[DONE] expressionPiece.DeterminePreviewSprite
[DONE] delete Keyboard.cs if obsolete
[DONE] In expressionPiece.OnDrop: the dropped expression COPIES from the keyboard

1. when pieces combine, whole new piece!
2.  In expressionPiece.OnDrop: make sure you can only combine expressions in the workspace---keyboard should stay constant
4. Clean up comments
4. update ExpressionPiece image only when necessary

----------------------------------------------------------------------------------------------
TODO with Bill Thursday:
	1. edit ExpressionPiece constructor to create its own Expression -- is this what we want? i.e. in the future, making 
	   an Expression will be done through making an ExpressionPiece

~~~~~~~~~~~~~~~~
Bill's Remarks (6/27):
  - the symbols on the keyboard shouldn't move, as you've noted, and they also shouldn't change form when a potential argument is in play. They should be inert, and always in the same position on the keyboard. Ultimately there will be multiple tabs for the keyboard.
    What I imagine this means implementation-wise is that the symbols on the keyboard aren't the Word objects that are manipulated on the workspace: rather, they're template-objects, let's call them "WordSpawner"s, which instantiate whichever Word is associated with the WordSpawner whenever a user drags from it. So the DOOR symbol on the keyboard would be an object whose OnDrag method instantiates a container for a new Word("Door", ...)
      * WordSpawners don't move, change to input/output form, etc. because they aren't themselves ExpressionPiece objects. This would seem to solve a lot of the outstanding problems you're setting out to fix, and wouldn't involve complicated checks for whether an object is on the workspace or not: Spawners are always in the keyboard, and ExpressionPieces are always on the workspace.
      * A WordSpawner takes a SemanticType and String as input. When it's time for the WordSpawner to make a Word, it'll pass these as arguments.
      * The WordSpawner will store the Image that's the name of the word. We can have a naming convention for the sprites to be <ID>.png where <ID> is the ID string of the word, and so we find the right image by taking the inputted string and getting our file based off of it.
  - To answer the question in 1.: No, I don't think so. The ExpressionPiece should have its expression as a field, but it shouldn't be the one creating it. The idea is to store the Image in the Container so that we don't have to recreate the image from scratch every time we make a new expression, but also keep Expressions from being Unity Objects with graphical fields so that it's not bloated. I'll talk more about this when we meet.
  - We need to see if multi-argument function expressions work.
    * That means we need to resize expressions as necessary. If an expression has three arguments, it should be at least 4 units (where one symbol without arguments is 1unitx1unit) wide, maybe more if one the inputs was a compound expression itself. And it should be at least 2 units high.
    * this'll mean a larger workspace is necessary.
  - I'd like to see expressions color coded by semantic type and for us to start using images for our symbols instead of fonts, and maintain a regular square size for them. It can be simple shapes for now.
~~~~~~~~~~~~~~~
