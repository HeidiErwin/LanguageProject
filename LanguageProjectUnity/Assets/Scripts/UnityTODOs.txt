Things Heidi needs to do UI/UX/Unity-wise(6/25 - 6/27):
[DONE] refactor WordPiece into ExpressionPiece
[DONE] make a GameController class to set up the keyboard / add expressions to the screen
	   will definitely be useful if not necessary later anyways
[DONE] expressionPiece.CanAccept --> GET and KEY working fine, bug w/ F & X
[DONE] expressionPiece.DetermineUpdatedSprite
[DONE] expressionPiece.DeterminePreviewSprite
[DONE] delete Keyboard.cs if obsolete
[DONE] In expressionPiece.OnDrop: the dropped expression COPIES from the keyboard
[DONE] implement ExpressionPieceSpawner, which should remove the need for the next 2 things:
[DONE] copying from keyboard puts pieces at end of keyboard
[DONE] In expressionPiece.OnDrop: make sure you can only combine expressions in the workspace---keyboard should stay constant
[DONE] when pieces combine, whole new piece!

----------------------------------------------------------------------------------------------
TODO with Bill Thursday:
	1. edit ExpressionPiece constructor to create its own Expression -- is this what we want? i.e. in the future, making 
	   an Expression will be done through making an ExpressionPiece --> Nope! See responses below for how this is going to be handled.

~~~~~~~~~~~~~~~~
Bill's Remarks (6/27):
  - the symbols on the keyboard shouldn't move, as you've noted, and they also shouldn't change form when a potential argument is in play. They should be inert, and always in the same position on the keyboard. Ultimately there will be multiple tabs for the keyboard.
    What I imagine this means implementation-wise is that the symbols on the keyboard aren't the Word objects that are manipulated on the workspace: rather, they're template-objects, let's call them "WordSpawner"s, which instantiate whichever Word is associated with the WordSpawner whenever a user drags from it. So the DOOR symbol on the keyboard would be an object whose OnDrag method instantiates a container for a new Word("Door", ...)
      * WordSpawners don't move, change to input/output form, etc. because they aren't themselves ExpressionPiece objects. This would seem to solve a lot of the outstanding problems you're setting out to fix, and wouldn't involve complicated checks for whether an object is on the workspace or not: Spawners are always in the keyboard, and ExpressionPieces are always on the workspace.
      * A WordSpawner takes a SemanticType and String as input. When it's time for the WordSpawner to make a Word, it'll pass these as arguments.
      * The WordSpawner will store the Image that's the name of the word. We can have a naming convention for the sprites to be <ID>.png where <ID> is the ID string of the word, and so we find the right image by taking the inputted string and getting our file based off of it.
  - To answer the question in 1.: No, I don't think so. The ExpressionPiece should have its expression as a field, but it shouldn't be the one creating it. The idea is to store the Image in the Container so that we don't have to recreate the image from scratch every time we make a new expression, but also keep Expressions from being Unity Objects with graphical fields so that it's not bloated. I'll talk more about this when we meet.
  - We need to see if multi-argument function expressions work, as well as function expressions with a higher type than e->t, as well as e->e expressions, etc... If you want inspiration for common semantic types, check out my Testing file in the AI folder.
    * That means we need to resize expressions as necessary. If an expression has three arguments, it should be at least 4 units (where one symbol without arguments is 1unitx1unit) wide, maybe more if one the inputs was a compound expression itself. And it should be at least 2 units high.
    * this'll mean a larger workspace is necessary.
  - I'd like to see expressions color coded by semantic type and for us to start using images for our symbols instead of fonts, and maintain a regular square size for them. It can be simple shapes for now.
~~~~~~~~~~~~~~~
Heidi's Response (6/27):
	- I can make an ExpressionPieceSpawner class that does what you wanted w/ WordSpawners
		* Now that I'm working on this and testing, it seems like it will be easier for the user to just click the symbols for them to spawn in the workspace, so I'm going to implement that.
		  We can change that later if we need to.
	- So rather than having the GameController create ExpressionPieces and pass in the info so that the ExpressionPiece can create its Expression field, you're suggesting we 
	  have the GameController not only create ExpressionPieces, but also create Expressions and then just pass the entire Expressions into the constructor of the ExpressionPiece. 
	  I can make that change.
	- Will ALL expressions be square? i.e. will a three-argument expression not be a wider rectangle, which accepts squares? I suppose it would be convenient to have 
	  every expression be square because argument boxes could then always be square without confusion
~~~~~~~~~~~~~~~
TODO After 6/27 (6/28 - 6/30):
[DONE] figure out if it's better to:
		* change prefabs from specific prefabs to general Piece & PieceSpawner prefabs, and then later set specifications OR --> this!
		* copy prefabs as we need more symbols, that can then be called by name
[DONE] remove bug from Draggable where placeholder remains and makes workspace appear shifted
[DONE] update ExpressionPiece image only when necessary
[DONE] PieceSpawner Image resolve bug

1. GenerateNewImage
	- [DONE] self-build using a color based on SemanticType
	- [DONE] get symbol from image
	- [DONE] box size depends on num args
	- box height depends on max height of args
	- argument positioning
	- remove DeterminePreviewSprite & DetermineUpdatedSprite -- ensure their functionalities are covered.
3. preview sprites
5. change names, which are currently Strings, to symbols, which are Images. Alternatively, keep names, but add in symbols.
6. argument indeces
7. if we implement an Expression Bank ever (user-saved expressions), we need to edit ExpressionPiece.SetExpression()
   to not make myArguments just an empty array
8. Clean up comments & Debugs
9. order doesn't change when new piece in workspace

COLORS:
	- outline gives current semtype
	- fill gives semtype that expr will become when all args filled in (output type)
	- empty input boxes have colored outline for type they accept, fill is semi transparent (look into alpha layers)
